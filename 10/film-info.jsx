const FilmInfo = () => {
    const [id, setId] = React.useState(1);
    const [film, setFilm] = React.useState({});
    
    React.useEffect(() => {
        console.log(`Hello from useEffect`);
        return () => console.log(`componentWillUnmount`);
   }, []);
    
    return (         
        <section className="block">
               <div>
                   <button
                       onClick={() => {setId((prevId) => prevId + 1)}}
                       className="custom-button"
                   >
                       Следующий фильм…
                   </button>                    
                   <h3>Идентификатор фильма: {id}</h3>
               </div>
               
               {film.name && <h1>{film.name}</h1>}
           </section>
    )
}


export default FilmInfo;

Теперь вернёмся к аналогии с методами componentDidMount и componentDidUpdate. Функция, зарегистрированная при помощи useEffect вызывается, но как быть, если нам требуется реализовать код, который должен вызываться лишь однократно, при монтировании компонента? То есть добиться полного соответствия методу componentDidMount. Сейчас кажется, что это невозможно, так как функция вызывается не только при монтировании компонента, но и при обновлении.

Для более гибкой настройки, вторым параметром в useEffect мы можем передать список зависимостей, от которых зависит вызов функции, которую мы регистрируем. Под зависимостями подразумеваются значения, при изменении которых следует вызывать функцию и тем самым применить «эффект». Начнём с простого примера. Передадим в качестве зависимостей пустой массив.

Передача пустого массива (отсутствия зависимостей) фактически говорит, что зависимостей никаких нет. А раз их нет, то значит функцию с эффектом (которую мы передали useEffect) следует выполнить лишь при монтировании компонента. Если в компоненте изменится состояние, то повторного применения эффекта не будет. Таким образом, мы получаем поведение аналогичное componentDidMount.