const FilmInfo = () => {
    const [id, setId] = React.useState(1);
    const [film, setFilm] = React.useState({});
    React.useEffect(() => console.log(`Hello from useEffect`));
    
    return (         
        <section className="block">
               <div>
                   <button
                       onClick={() => {setId((prevId) => prevId + 1)}}
                       className="custom-button"
                   >
                       Следующий фильм…
                   </button>                    
                   <h3>Идентификатор фильма: {id}</h3>
               </div>
               
               {film.name && <h1>{film.name}</h1>}
           </section>
    )
}


export default FilmInfo;

useEffect — позволяет зарегистрировать функцию с побочными эффектами. Напомним эту главную мысль ещё раз. Зарегистрированная функция будет вызываться каждый раз при рендере компонента. Зафиксируйте внимание на этой фразе.

Воспользуемся useEffect и передадим функцию с побочными эффектами. Простого вывода в консоль более, чем достаточно. Сразу после рендера компонента эта функция будет выполнена и в консоли мы увидим ожидаемую фразу. Нажмите несколько раз на кнопку «Следующий фильм». Состояние компонента будет меняться и это приводит к очередному вызову useEffect.

Какие выводы можно сделать прямо сейчас: раз функция, зарегистрированная с помощью useEffect вызывается сразу после добавления компонента в DOM, то этот хук позволяет решать те же задачи, которые в классовых компонентах решались за счёт componentDidMount. Но помимо вызова функции после рендера компонента, эта же функция будет вызываться на каждом обновлении компонента. Изменение состояния, пропсов будет приводить к повторному вызову функции, зарегистрированный через useEffect. Это поведение аналогично работе метода componentDidUpdate.