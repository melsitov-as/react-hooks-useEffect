const FilmInfo = () => {
    const [id, setId] = React.useState(1);
    const [film, setFilm] = React.useState({});
    
    React.useEffect(() => {
        console.log(`Hello from useEffect`);
        return () => console.log(`componentWillUnmount`);
   }, [id]);
    
    return (         
        <section className="block">
               <div>
                   <button
                       onClick={() => {setId((prevId) => prevId + 1)}}
                       className="custom-button"
                   >
                       Следующий фильм…
                   </button>                    
                   <h3>Идентификатор фильма: {id}</h3>
               </div>
               
               {film.name && <h1>{film.name}</h1>}
           </section>
    )
}


export default FilmInfo;

Помимо пустого массива мы можем передать идентификаторы переменных, при изменении содержимого которых следует применить эффект. Применительно к нашему примеру может быть id и (или) film.

Попробуйте нажать на кнопку «Следующий фильм». Кроме применения эффекта (той самой функции) мы видим, что выводится фраза «componentWillUnmount». Почему? Дело в том, что при выполнениии побычных эффектов нам может потребоваться выполнить очистку ресурсов. Например, если в эффект (то что мы регистрируем в useEffect) мы воспользуемся таймером, то нам где-то нужно будет его очистить, то есть выполнить clearTimeout. Тоже самое с обработчиками событий. Если мы зачем-то хотим подписаться на событие, то мы должны снять обработчик. Все перечисленные задачи решаются в той самой функции, которую возвращается функция с побочным эффектом. Поэтому при очередном эффекте выполняется очистка предыдущего эффекта. Выходит, что этот механизм расширяет поведение аналогичного метода жизненного цикла componentWillUnmount.